* algogorithmic composition repository
** directory files
- berkowitz-duets-1.pwgl
- mozart-duet-rhythms.pwgl
- plist-db1.pwgl
- project-overview.org
- recompose-simple-scripted-pitches.pwgl
- rtm-database.lisp
- rtm-reference.org
- 
** documenting directory files
*** recompose-simple-scripted-pitches.pwgl
    :PROPERTIES:
    :ID:       F8956FC2-0518-44EB-8F99-7CC95D8551DA
    :END:
lost code for generating pitches???
**** use of enp-script box to re-write pitches

#+BEGIN_SRC lisp
(* ?1 
   (?if (let ((midi (nth (1- (notenum ?1)) (pwgl-value :pitches))))
          (when midi (setf (midi ?1) midi))))
   "set midis")


#+END_SRC

**** the rhythms for a piece
#+BEGIN_SRC lisp
(
:r111 ;; three quarters
:r15555 ;; one quarter four eighths
:r1111 ;; four quarters
:r21 ;; half note, quarter
:r555555 ;; six eighths
:r1-1-6666 ;; quarter, quarter rest, four sixteenths
:r1111
)
#+END_SRC

**** my ENP-VOICE-RTM library functions (imported as PWGL library)
     :PROPERTIES:
     :ID:       9FA05B93-BA7A-4DCB-853D-9D7B65366F9C
     :END:

***** ENP-VOICE-RTM library; convert-measures
:PROPERTIES:
:ID:       995AEADF-6765-44D4-BE56-246FAF74CB4F
:END:

#+BEGIN_SRC lisp
(in-package :ENP-VOICE-RTM)

(defun sub-beat-converter (sub)
  (let ((measure-sub sub))
    (cons (car measure-sub)
	  (let ((b (cadr measure-sub)))
	    (list (loop for n in b collect `(,n :notes (60))))))))

(defun convert-beats (measure) (mapcar #'sub-beat-converter measure))

(defun convert-measures (measures) (mapcar #'convert-beats measures))

#+END_SRC

***** sample loop to search through *rtm-db1* for rtms corresponding to "tags"
:PROPERTIES:
:ID:       E7B09E73-A58F-4025-B05D-562984779F49
:END:
#+BEGIN_SRC lisp
(loop for tag in score-ref collect (getf cl-user::*rtm-db1* tag))
#+END_SRC

***** example two-measure "score" of one voice
:PROPERTIES:
:ID:       CC7F6DB2-9723-4D60-BE66-CC1EFA843303
:END:
#+BEGIN_SRC lisp
((1 (1 1)) (2 (1)) (1 (1 1)))
((1 (1 1 1)) (2 (1)) (1 (1 1)))
#+END_SRC
**** available rtms in this file

#+BEGIN_SRC lisp
(defparameter *rtm-db1* 
  '(
    ;;; 4/4 rtms
    :r4 ((4 (1)))

    :r22 ((2 (1)) (2 (1)))

    :r31 ((3 (1)) (1 (1)))

    :r13 ((1 (1)) (3 (1)))

    :r211 ((2 (1)) (1 (1)) (1 (1)))

    :r121 ((1 (1)) (2 (1)) (1 (1)))

    :r112 ((1 (1)) (1 (1)) (2 (1)))

    :r22 ((2 (1)) (2 (1)))

    :r55552 ((2 (1 1 1 1)) (2 (1)))

    :r25555 ((2 (1)) (2 (1 1 1 1)))

    :r55255 ((1 (1 1)) (2 (1)) (1 (1 1)))

    :r555511 ((2 (1 1 1 1)) (2 (1 1)))

    :r115555 ((2 (1 1)) (2 (1 1 1 1)))

    :r1111 ((1 (1)) (1 (1)) (1 (1)) (1 (1)))

    ;;; 3/4 rtms
    :R1-1-6666 ((1 (1)) (1 (-1)) (1 (1 1 1 1)))
    
    :R555555 ((1 (1 1)) (1 (1 1)) (1 (1 1)))

    :r12 ((1 (1)) (2 (1)))
    
    :R21 ((2 (1)) (1 (1)))

    :R1111 ((1 (1)) (1 (1)) (1 (1)) (1 (1)))

    :R15555 ((1 (1)) (1 (1 1)) (1 (1 1)))

    :R111 ((1 (1)) (1 (1)) (1 (1)))))
#+END_SRC
*** plist-db1.pwgl
first use of library function--no pitch information
*** mozart-duet-rhythms.pwgl
*** rtm-database.lisp
*** project-overview.org
*** rtm-reference.org
*** berkowitz-duets-1.pwgl
* basic collection of PMC rules
** copied straight from PWGL tutorial
#+BEGIN_SRC lisp
(* ?1 ?2                     ;;PM-part
  (?if (/= ?1 ?2))         ;;Lisp-code part
  "No equal adjacent values")

(* ?1 ?2 
   (?if (member (mod12 (- ?2 ?1)) '(5 6)))
   "mod12 Interval rule")

(* ?1 
  (?if (not (member ?1 (rest rl)))) 
  "No duplicates")

(* ?1 
   (?if (not (member (mod ?1 12) (rest rl) :key #'mod12)))
   "No pitch class duplicates")

(* 
   (?if (apply #'< l)) 
  "Result in ascending order")

(i1 i2 i4 i6 
  (?if (eq-SC? '(4-1) i1 i2 i4 i6)) 
  "index rule")




#+END_SRC
