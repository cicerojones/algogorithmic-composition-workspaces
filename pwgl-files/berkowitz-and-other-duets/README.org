* STEPS to understanding the "Berkowitz Project"
Initially, more than one thing was being advanced here:
- inputing rhythms quickly, so as to set the pitches of a single line
  piece most quickly using a MIDI controller
  - see: SIMPLE-TEMPLATE-FOR-TRANSCRIBING-RHYTHMS.pwgl
- doing actual algo composition using CSP via enp-script and a chord-editor
  - see: RECOMPOSE-SIMPLE-SCRIPTED-PITCHES.pwgl

But a proper re-organization is in order, achieving a "separation of
concerns," which include:

1. quick entry of scores
2. determining the pitches of some input rhythm via CSP
3. understanding how enp-script rules work
4. eventually being able to work with multi-voice scores
5. dealing with quirks and nuances of score output


* Using PWGL and ENP regularly
** music representation
Not enough has been said about the importance of grappling with /music representation/, or rather, how ENP approaches this topic.

What this means in practice for anyone who endeavors to take advantage of all this Lisp-based system offers is that each layer of the superstructure of an ENP score must be familiar and friendly if you are to get anywhere!

So, to start with, do you have a good mental model of "the stack" and how it is assembled (and how to parse it when it is assembled as text)?

note -- chord -- beat -- measure -- voice -- part -- score

What *is* each one of those in your mind?
** need for personal tutorial system
When opening the PWGL Tutorial, you will be dropped into the "PWGL browser." 

But little did you realize the virtues of this!

Once in the broswer you can choose to set any folder of PWGL patches to be ready for use as a "tutorial" style experience.

One main advantage of this is that you can navigate quickly among related files, perhaps in a way that makes for a more helpful learning experience.

But another advantage is that you can, when editing a patch that you are using or will be using for the "tutorial" experience, you can also create "documentation" that will appear in the side window in when you're in this "tutorial mode."

The only disadvantage is that edits made to the patch this way will NOT be saved.
** achieving a rapproachment between text and GUI
The facts are:

musical or sonic events allow more than one way to be experienced, understood or analyzed. So what do you as musician attempting to incorporate the computer into his work?

How do you balance conventional music notation, alphanumeric approximations of or instructions for sound-making, and the actual experience of hearing and executing or controlling in real time music?

For the sake of Lisp-based music environments, the answer is not obvious, but clearly there are advantages, whenever computer code is involved, to having skills with a primarily text-based medium. So what do you with Emacs, Common Lisp code as found in PWGL, and the various GUI visualizations that PWGL makes available for organizing your work and thinking?


* STEPS to transcribe a melody from a score
  :PROPERTIES:
  :ID:       D3EAAF33-EC29-43DA-A1A4-3A1EF1C25A3C
  :END:
** setup for soundfonts with fluidsynth 
- connect MIDI controller
- start up fluid synth
#+BEGIN_SRC bash
fluidsynth /Users/b/Library/Audio/Sounds/Banks/GeneralUser\ GS\ MuseScore\ v1.442.sf2
#+END_SRC
** [#A] use PWGL
 - set midi out to fluidsynth (make sure MIDI in is correct)
 - open an old patch or create a new one
   - say, plist-db1
   - use a "simple template" pwgl file and copy into new dedicated
     pwgl file
   - to create a new one from scratch, you'll need:
     - a Score-editor box
     - enp-constructor
       - can be set to different "levels" of a score depending on the
         nature of its input
         - use "voice" for output of my "convert-measures" library object
           - to add a "convert-measures" object, you'll need to
             double-click to bring up the "object search" interface
             - set Package to "enp-voice-rtm" and search for "convert-measures"
               - failure to set the package will produce no search results
           - convert-measures expects a certain structure to be passed
             - see code at [[id:995AEADF-6765-44D4-BE56-246FAF74CB4F][ENP-VOICE-RTM library; convert-measures]]
             - if you pass a plain-text box, you can fill it with the
               following: [[id:CC7F6DB2-9723-4D60-BE66-CC1EFA843303][example two-measure "score" of one voice]]
           - to create a new, arbitrary score, you'll need to loop
             over some lightly structured input
             - [[id:E7B09E73-A58F-4025-B05D-562984779F49][sample loop to search through *rtm-db1* for rtms corresponding to "tags"]]
               - how do you get the rtm database loaded? automatically?
             - create series of numerical inputs on succesive new
               lines in emacs and add leading colons per measure
** transcribe a rhythmic framework
the rhythm framework for a score will need to be entered by hand. How should you best do this?

in emacs, say, type a measure per line as:

111
15555
21

(The kind of numbers you can/should type to get a given rhythm depends entirely on the "rtm-db" you are using. Understanding this system is essential).

Then go back and insert :r before each line (using emacs macros, say)

You can then either create a variable to contain the contents of this work, as below:


#+BEGIN_SRC lisp
(setq score '(:r111 :r15555 :r21))
#+END_SRC

Or, you can simply copy/paste each line into a 'text-box' object (which will by default wrap the list in a set of parens when the box is processed by the next box).

** import "list of keyword" symbols into PWGL somehow
You will then be relying on two pieces of Lisp code

One will be 'convert-measures', which is loaded as part of a library

[[id:9FA05B93-BA7A-4DCB-853D-9D7B65366F9C][my ENP-VOICE-RTM library functions (imported as PWGL library)]]

But, more immediately, you will need a way to take what you just typed
and "translate" it into a form that convert-measures can use. This is
done by some kind of looping and looking up your symbols against a database,
which you will have to provide, as below. Your *rtm-db* should be
contained with a "Lisp-code-box" which will need the proper in-package
statement, and a "defparameter"

** see example of current PWGL file
Here's an example, taken from [[file:plist-db1.pwgl][file:~/Github-repos/algogorithmic-composition-workspaces/pwgl-files/berkowitz-and-other-duets/plist-db1.pwgl]]

#+BEGIN_SRC lisp
(loop for tag in score-ref collect (getf cl-user::*rtm-db1* tag))
#+END_SRC

experiment using a dedicated "empty text-box" in whatever pwgl patch
you switch to

To start editing the pitches of this rhythmic framework

- make sure the MIDI-IN is set to your correct controller
- open the ENP-score
- select 'start MIDI input' (Cmd-K) from the "Score" menubar
- click on a note stem and starting "sight-reading" the melody
- right click on the resulting "score" to edit various parameters
  - Tempo
- export (as MIDI, XML?) from the File menu
- convert to wav via command line?
  - use timidity
#+BEGIN_SRC bash
timidity -Ow ~/Google\ Drive/Audio_uploads/wav-file-uploads/odd-gappy-minor-arp.mid -o ~/Google\ Drive/Audio_uploads/wav-file-uploads/odd-gappy-minor-arp.wav
#+END_SRC
- make sure you save to a desirable directory and convert into a
  desirable directory
  - open Google Drive in the background ensure 'cloud' syncing
* Common Lisp and PWGL work toward algorithmic composition
  :PROPERTIES:
  :ID:       EE7143F7-E35C-4141-921B-4E271CC8A7E3
  :END:
WRT to major (incremental) development
** Files (see project-overview.org as well)
/Users/b/Github-repos/algogorithmic-composition-workspaces/pwgl-files/berkowitz-and-other-duets/

- README.org
  - this file
- project-overview.org

- rtm-reference.org

- recompose-simple-scripted-pitches.pwgl
  - see project-overview.org: [[id:F8956FC2-0518-44EB-8F99-7CC95D8551DA][recompose-simple-scripted-pitches.pwgl]]
  - uses a handful of rtms and an abstraction for voicing pitch-class
    sets
  - realizes pitches in a score-editor with an enp-script box

berkowitz-duets-1.pwgl
mozart-duet-rhythms.pwgl
plist-db1.pwgl

- rtm-database.lisp
  - not needed by particular patch, but holds formatted past work that
    can be copied?

** start fluidsynth before PWGL
call from command line with soundfont argument such as

~/Library/Audio/Sounds/Banks/GeneralUser\ GS\ MuseScore\ v1.442.sf2

** STEPS for recompose-simple-scripted-pitches 
*** TODO figure out how to quickly enter new rtms
*** STEPS to quickly export MIDI version (to Audio_Uploads)
of score and convert to audio via timidity in bash
ex. 
#+BEGIN_SRC bash
timidity -Ow ~/Google\ Drive/Audio_uploads/wav-file-uploads/odd-gappy-minor-arp.mid -o ~/Google\ Drive/Audio_uploads/wav-file-uploads/odd-gappy-minor-arp.wav
#+END_SRC
Can be called from EMACS shell (even in babel bash block?)
* developing a library of shortcut notations
[2016-10-24 Mon]
for now, see [[id:61A55E31-3845-4C21-96AA-EEB7923C03CC][canon of basic 4/4 rhythms (whole, half, dotted-half, quarters, eighths)]]

** issues to deal with 
   :PROPERTIES:
   :ID:       135AB3A6-99E8-4CB7-9CAC-684DEFA94706
   :END:

- pick-up measures
- rests
- dotted notes
- regex looping would be better than relying on kmacros?
- consider editing a pwgl "in-place" in emacs, via text?
- stemming and connecting eighths/sixteenths
- not forgetting the original pwgl "ENP" score-format details
  - when it comes to doing multiple parts/lines/chords
- clefs
- key signatures and accidentials
  - part of the Preferences?
    - Tools:Preference Settings
    - Settings:Document Preferences
      - Alterations
	- Alterations Mapping (flats)
    - Settings:ENP Application Preferences
- metronome settings
- layout, measures/systems per page



